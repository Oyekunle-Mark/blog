<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>An Introduction to MySQL Locks</title>
    <meta name="date" content="2022-01-03">
    <meta name="tags" content="sql, locks, databases">
    <!-- Add your CSS here -->
    <link rel="stylesheet" href="/static/css/style.css">
    <!-- For code highlighting -->
    <link rel="stylesheet" href="/static/css/pygments.css">
</head>
<body>
    <article>
        <header>
            <h1>An Introduction to MySQL Locks</h1>
            <div class="metadata">
                <time datetime="2022-01-03">January 03, 2022</time>
                <div class="tags">
                    
                        <span class="tag">sql</span>
                    
                        <span class="tag">locks</span>
                    
                        <span class="tag">databases</span>
                    
                </div>
            </div>
        </header>
        <div class="content">
            <p>Concurrent access to database records from different client sessions can impact data integrity and lead to the expected behavior of computer programs that perform specific actions depending on the value of the data retrieved from the database. In this article, I will give you an introduction to how MySQL locks can be used for concurrency control and guarantee data integrity while allowing multiple users or sessions to safely interact with data. I will also write about the popular types of MySQL locks.</p>
<h2>Prerequisite</h2>
<p>This article assumes that you have an intermediate understanding of SQL. Examples are presented, and concepts are explained using MySQL.</p>
<h2>What is a lock?</h2>
<p>The <a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">wikipedia</a> page on locks has this to say about what a lock is:</p>
<blockquote>
<p>In computer science, a lock or mutex (from mutual exclusion) is a synchronization primitive: a mechanism that enforces limits on access to a resource when there are many threads of execution. A lock is designed to enforce a mutual exclusion concurrency control policy, and with a variety of possible methods, there exist multiple unique implementations for different applications.</p>
</blockquote>
<p>From a database standpoint, a lock is used to restrict some database data so that only one session or user can make changes to that data.</p>
<h2>Why you should use database locks</h2>
<p>The biggest benefit of using database locks is that when employed correctly, it guarantees data integrity while allowing concurrent access to data. Database locks exist to prevent two or more users or sessions from updating the same exact piece of data at the same exact time.</p>
<p>You should use locks to prevent potential loss of data due to concurrent updates.</p>
<h2>How to use MySQL locks</h2>
<p>In this section, we will learn about how to use locks in MySQL. The two popular types of MySQL locks will also be explained.</p>
<p>Let us begin by creating the table we will be demonstrating with. Use the statement below to create the <code>members</code> table.</p>
<div class="codehilite"><pre><span></span><code><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">members</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="p">,</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>

<p>We will also be connecting to the database from two sessions so we can demonstrate the behavior of each lock type. We can check the connection id of the current session as follows:</p>
<div class="codehilite"><pre><span></span><code><span class="k">SELECT</span><span class="w"> </span><span class="n">CONNECTION_ID</span><span class="p">();</span>
</code></pre></div>

<p>The syntax for acquiring a table lock is presented below:</p>
<div class="codehilite"><pre><span></span><code><span class="c1">-- lock a single table</span>
<span class="k">LOCK</span><span class="w"> </span><span class="n">TABLES</span><span class="w"> </span><span class="k">table_name</span><span class="w"> </span><span class="p">[</span><span class="k">READ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">WRITE</span><span class="p">]</span>

<span class="c1">-- lock many tables</span>
<span class="k">LOCK</span><span class="w"> </span><span class="n">TABLES</span><span class="w"> </span><span class="n">table_name1</span><span class="w"> </span><span class="p">[</span><span class="k">READ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">WRITE</span><span class="p">],</span><span class="w"> </span><span class="n">table_name2</span><span class="w"> </span><span class="p">[</span><span class="k">READ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">WRITE</span><span class="p">],</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">;</span>
</code></pre></div>

<p>A client session that acquires a lock is solely responsible for releasing the lock. A session cannot release a lock for another session.</p>
<p>Locks are released using the <code>UNLOCK</code> statement.</p>
<div class="codehilite"><pre><span></span><code><span class="n">UNLOCK</span><span class="w"> </span><span class="n">TABLES</span><span class="p">;</span>
</code></pre></div>

<h2>Types of MySQL locks</h2>
<p>We will look at the popular types of MySQL locks and how to use them in this section of the article.</p>
<p>The two types of MySQL locks we will learn in this article are:</p>
<ol>
<li>Read (Shared) locks</li>
<li>Write (Exclusive) locks</li>
</ol>
<h3>1. Read (Shared) locks</h3>
<p>Read or shared locks are locks that prevent a write lock from being acquired but not other read locks. It allows multiple sessions to obtain a lock on a table for the sole purpose of reading it.</p>
<p>Read locks have the following attributes:</p>
<ol>
<li>A read lock for a table can be acquired by multiple sessions at the same time. Other sessions can also read data from the table without acquiring the lock.</li>
<li>The client session that holds a read lock can only read data from the table, but cannot write. Other sessions cannot write data to the table until the lock is released. A write operation from another session will be put into the waiting states until the read lock is released.</li>
</ol>
<p>To demonstrate, we will make some writes into the <code>members</code> table we created in the previous section, acquire a read lock on the table and perform a read.</p>
<p>First, we will check the connection id of the session we will be performing these actions from:</p>
<div class="codehilite"><pre><span></span><code><span class="k">SELECT</span><span class="w"> </span><span class="n">CONNECTION_ID</span><span class="p">();</span>
</code></pre></div>

<p><img alt="" src="https://i.imgur.com/UTGGGh8.png" /></p>
<p>Now we will proceed with the rest of the operations.</p>
<div class="codehilite"><pre><span></span><code><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">members</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span>
<span class="k">VALUES</span><span class="p">(</span><span class="s1">&#39;Moremi Lewis&#39;</span><span class="p">);</span>

<span class="k">LOCK</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">members</span><span class="w"> </span><span class="k">READ</span><span class="p">;</span>

<span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">members</span><span class="p">;</span>
</code></pre></div>

<p>The result of these statements is predictable. The select statement returns the expected output:</p>
<p><img alt="" src="https://i.imgur.com/VAcHBrP.png" /></p>
<p>Let us take it a step further by attempting to perform a write into the table.</p>
<div class="codehilite"><pre><span></span><code><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">members</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span>
<span class="k">VALUES</span><span class="p">(</span><span class="s1">&#39;Sango Uche&#39;</span><span class="p">);</span>
</code></pre></div>

<p>This statement produces an error because a client session that holds a read lock can only read data from the table, but cannot write.</p>
<p><img alt="" src="https://i.imgur.com/NeqglKs.png" /></p>
<p>Next, we will check the behavior of a read lock from another session.</p>
<p>Using another session, we will attempt to perform read and write operations.</p>
<p>We can confirm that it is indeed another session by using the <code>CONNECTION_ID()</code> MySQL function to check the current connection id. </p>
<div class="codehilite"><pre><span></span><code><span class="k">SELECT</span><span class="w"> </span><span class="n">CONNECTION_ID</span><span class="p">();</span>
</code></pre></div>

<p><img alt="" src="https://i.imgur.com/j9wfFtB.png" /></p>
<p>Now let us read from the <code>members</code> table.</p>
<div class="codehilite"><pre><span></span><code><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">members</span><span class="p">;</span>
</code></pre></div>

<p>The read request from another session is processed.</p>
<p><img alt="" src="https://i.imgur.com/WV4mcAL.png" /></p>
<p>A write into a table with a read lock from another session will be put in the <code>waiting</code> state until the lock is released. Let us verify this behavior by performing the following actions:</p>
<p>Insert into the <code>members</code> table:</p>
<div class="codehilite"><pre><span></span><code><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">members</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span>
<span class="k">VALUES</span><span class="p">(</span><span class="s1">&#39;Mallam Uba&#39;</span><span class="p">);</span>
</code></pre></div>

<p>The server waits while the lock is held.</p>
<p><img alt="" src="https://i.imgur.com/YrZL9DE.png" /></p>
<p>We can view the state of the write using the <code>SHOW PROCESSLIST</code> statement.</p>
<p><img alt="" src="https://i.imgur.com/Pf9ho1V.png" /></p>
<p>The state is <code>Waiting for table metadata lock</code>.</p>
<p>From the first session, release the lock.</p>
<div class="codehilite"><pre><span></span><code><span class="n">UNLOCK</span><span class="w"> </span><span class="n">TABLES</span><span class="p">;</span>
</code></pre></div>

<p>Query for all members from the second session.</p>
<div class="codehilite"><pre><span></span><code><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">members</span><span class="p">;</span>
</code></pre></div>

<p><img alt="" src="https://i.imgur.com/wmsmbuS.png" /></p>
<p>We can see that the write is processed after the session holding the lock releases it.</p>
<h3>1. Write (Exclusive) locks</h3>
<p>Write or exclusive locks are locks that prevent any other lock of any kind from being obtained from another session on the same table.</p>
<p>Write locks have the following attributes:</p>
<ol>
<li>The session that holds a write lock on a table can read and write data from the table.</li>
<li>Other sessions cannot read or write data to the table until the write lock is released.</li>
</ol>
<p>We will validate these attributes by obtaining a write lock from the first session and attempt to perform a write from the second session.</p>
<p>From the first session, lock the <code>members</code> table.</p>
<div class="codehilite"><pre><span></span><code><span class="k">LOCK</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">members</span><span class="w"> </span><span class="k">WRITE</span><span class="p">;</span>
</code></pre></div>

<p>The session with the write lock can perform a read and write as demonstrated below:</p>
<div class="codehilite"><pre><span></span><code><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">members</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span>
<span class="k">VALUES</span><span class="p">(</span><span class="s1">&#39;Another Member&#39;</span><span class="p">);</span>

<span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">members</span><span class="p">;</span>
</code></pre></div>

<p><img alt="" src="https://i.imgur.com/GpUxmUo.png" /></p>
<p>Now from the second session, let us attempt to write into the table.</p>
<div class="codehilite"><pre><span></span><code><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">members</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span>
<span class="k">VALUES</span><span class="p">(</span><span class="s1">&#39;second session Member&#39;</span><span class="p">);</span>
</code></pre></div>

<p>The operation goes into the <code>waiting state</code>. We can check this using <code>SHOW PROCESSLIST</code></p>
<div class="codehilite"><pre><span></span><code><span class="k">SHOW</span><span class="w"> </span><span class="n">PROCESSLIST</span>
</code></pre></div>

<p><img alt="" src="https://i.imgur.com/YktKW6W.png" /></p>
<p>From the first session, release the lock and query the table, the write is done.</p>
<div class="codehilite"><pre><span></span><code><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">members</span>
</code></pre></div>

<p><img alt="" src="https://i.imgur.com/2mxq1AK.png" /></p>
<h2>Conclusion</h2>
<p>Guaranteeing data integrity and providing concurrency control so that multiple processes of our application can use database data safely is a standard requirement in every well-built computer program. MySQL locks are used to ensure that our database records are not left in an inconsistent or invalid state due to the interaction of multiple sessions with it.</p>
<p>This article demonstrated how MySQL read and write locks can be used to eliminate inaccuracies due to race conditions when multiple instances of our programs attempt to access database records at the same time.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p><a href="https://en.wikipedia.org/wiki/Tmux">Tmux</a>&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
        </div>
    </article>
</body>
</html>